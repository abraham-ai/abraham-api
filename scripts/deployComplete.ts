import { execSync } from "child_process";
import { readFileSync, writeFileSync, existsSync } from "fs";
import { createPublicClient, createWalletClient, http, parseAbi, Address, Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { base, baseSepolia } from "viem/chains";
import * as dotenv from "dotenv";
import hre from "hardhat";

dotenv.config();

/**
 * Complete Deployment Script for TheSeeds
 *
 * This script automates the entire deployment process:
 * 1. Generate FirstWorks snapshot
 * 2. Generate Merkle tree
 * 3. Compile contracts
 * 4. Deploy TheSeeds contract
 * 5. Update .env.local with contract address
 * 6. Update ABI files (lib/abi/theSeeds.ts and lib/abi/TheSeeds.json)
 * 7. Update Merkle root on contract
 * 8. Grant CREATOR_ROLE to relayer
 * 9. Create test seed
 *
 * Key Implementation Details:
 * - Uses full compiled ABI (not parseAbi) for proper error decoding
 * - Reads role hashes from contract instead of hardcoding
 * - Includes state propagation delays (2s after state changes)
 * - Gets seed ID from contract return value via simulation
 * - Waits for contract to be ready after deployment
 * - Handles both array and object return formats from viem
 *
 * Usage:
 *   NETWORK=baseSepolia tsx scripts/deployComplete.ts
 *   NETWORK=base tsx scripts/deployComplete.ts
 *
 * Or via npm scripts:
 *   npm run deploy:complete:base-sepolia
 *   npm run deploy:complete:base
 *
 * See docs/DEPLOYMENT.md for detailed documentation.
 */

// Test IPFS hash for initial seed
const TEST_IPFS_HASH = "ipfs://QmTiAN3G6xvgnE6hEgUMbs8T2zCZzuwEm1zPvvn4iQgKNa";

// Role hashes - these will be read from the contract
let CREATOR_ROLE: Hex;

// Network configuration
const networks = {
  base: {
    chain: base,
    rpcUrl: process.env.BASE_RPC_URL || "https://mainnet.base.org",
    name: "Base Mainnet",
    explorer: "https://basescan.org",
  },
  baseSepolia: {
    chain: baseSepolia,
    rpcUrl: process.env.BASE_SEPOLIA_RPC_URL || "https://sepolia.base.org",
    name: "Base Sepolia",
    explorer: "https://sepolia.basescan.org",
  },
};

interface DeploymentResult {
  contractAddress: string;
  merkleRoot: string;
  testSeedId: number;
  txHashes: {
    deployment: string;
    merkleUpdate: string;
    creatorGrant: string;
    testSeed: string;
  };
}

function executeCommand(command: string, description: string): void {
  console.log(`\nüìù ${description}...`);
  try {
    execSync(command, { stdio: "inherit" });
    console.log(`‚úÖ ${description} completed`);
  } catch (error) {
    console.error(`‚ùå Failed: ${description}`);
    throw error;
  }
}

async function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function waitForContract(
  publicClient: any,
  contractAddress: Address,
  abi: any,
  maxRetries: number = 10
): Promise<void> {
  console.log("‚è≥ Waiting for contract to be ready for reads...");

  for (let i = 0; i < maxRetries; i++) {
    try {
      await publicClient.readContract({
        address: contractAddress,
        abi,
        functionName: "paused",
      });
      console.log("‚úÖ Contract is ready!");
      return;
    } catch (error) {
      if (i < maxRetries - 1) {
        console.log(`   Attempt ${i + 1}/${maxRetries} - waiting 3 seconds...`);
        await sleep(3000);
      } else {
        throw new Error(`Contract not ready after ${maxRetries} attempts`);
      }
    }
  }
}

function updateEnvFile(contractAddress: string): void {
  console.log("\nüìù Updating .env.local file...");

  const envPath = ".env.local";
  let envContent = "";

  if (existsSync(envPath)) {
    envContent = readFileSync(envPath, "utf-8");
  }

  // Update or add L2_SEEDS_CONTRACT
  if (envContent.includes("L2_SEEDS_CONTRACT=")) {
    envContent = envContent.replace(
      /L2_SEEDS_CONTRACT=.*/,
      `L2_SEEDS_CONTRACT=${contractAddress}`
    );
  } else {
    envContent += `L2_SEEDS_CONTRACT=${contractAddress}\n`;
  }

  writeFileSync(envPath, envContent);
  console.log(`‚úÖ Updated .env.local with contract address: ${contractAddress}`);
}

function updateAbiTypescriptFile(contractAddress: string): void {
  console.log("\nüìù Updating lib/abi/theSeeds.ts...");

  const abiJsonPath = "./lib/abi/TheSeeds.json";
  const abiTsPath = "./lib/abi/theSeeds.ts";

  if (!existsSync(abiJsonPath)) {
    console.log("‚ö†Ô∏è  ABI JSON not found, skipping TypeScript ABI update");
    return;
  }

  const abi = JSON.parse(readFileSync(abiJsonPath, "utf-8"));

  const tsContent = `/**
 * TheSeeds Contract ABI and Address
 *
 * Auto-generated by deployment script
 * Contract Address: ${contractAddress}
 */

export const SEEDS_ABI = ${JSON.stringify(abi, null, 2)} as const;

export const SEEDS_CONTRACT_ADDRESS = "${contractAddress}" as const;
`;

  writeFileSync(abiTsPath, tsContent);
  console.log(`‚úÖ Updated ${abiTsPath}`);
}

async function main() {
  console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  console.log("‚ïë     TheSeeds Complete Deployment Automation Script        ‚ïë");
  console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");

  // Get network from environment
  const networkName = (process.env.NETWORK || "baseSepolia") as keyof typeof networks;
  const networkConfig = networks[networkName];

  if (!networkConfig) {
    throw new Error(`Invalid network: ${networkName}. Valid options: ${Object.keys(networks).join(", ")}`);
  }

  console.log(`üåê Network: ${networkConfig.name}`);
  console.log(`üîó Chain ID: ${networkConfig.chain.id}\n`);

  // Validate environment variables
  console.log("üîç Validating environment variables...");

  if (!process.env.PRIVATE_KEY) {
    throw new Error("PRIVATE_KEY not set in environment");
  }

  if (!process.env.RELAYER_PRIVATE_KEY) {
    console.warn("‚ö†Ô∏è  RELAYER_PRIVATE_KEY not set - using PRIVATE_KEY as relayer");
  }

  if (!process.env.ALCHEMY_API_KEY) {
    throw new Error("ALCHEMY_API_KEY not set in environment");
  }

  if (!process.env.FIRSTWORKS_CONTRACT_ADDRESS) {
    throw new Error("FIRSTWORKS_CONTRACT_ADDRESS not set in environment");
  }

  console.log("‚úÖ Environment variables validated\n");

  const result: Partial<DeploymentResult> = {
    txHashes: {} as any,
  };

  // ============================================================
  // STEP 1: Generate FirstWorks Snapshot
  // ============================================================
  executeCommand("npm run snapshot:generate", "Generating FirstWorks snapshot");

  // ============================================================
  // STEP 2: Generate Merkle Tree
  // ============================================================
  executeCommand("npm run merkle:generate", "Generating Merkle tree");

  // Load Merkle root
  const merkleData = JSON.parse(readFileSync("./lib/snapshots/firstWorks_merkle.json", "utf-8"));
  result.merkleRoot = merkleData.root;
  console.log(`\nüìã Merkle Root: ${result.merkleRoot}`);

  // ============================================================
  // STEP 3: Compile Contracts
  // ============================================================
  executeCommand("npm run compile", "Compiling contracts and extracting ABI");

  // Verify ABI files were created
  const abiJsonPath = "./lib/abi/TheSeeds.json";
  if (!existsSync(abiJsonPath)) {
    throw new Error(`ABI file not found at ${abiJsonPath}. Compilation may have failed.`);
  }
  console.log(`‚úÖ ABI file verified at ${abiJsonPath}`);

  // ============================================================
  // STEP 4: Deploy TheSeeds Contract
  // ============================================================
  console.log("\nüìù Deploying TheSeeds contract...");

  const privateKey = (process.env.PRIVATE_KEY.startsWith("0x")
    ? process.env.PRIVATE_KEY
    : `0x${process.env.PRIVATE_KEY}`) as Hex;

  const account = privateKeyToAccount(privateKey);

  const client = createWalletClient({
    account,
    chain: networkConfig.chain,
    transport: http(networkConfig.rpcUrl),
  });

  const publicClient = createPublicClient({
    chain: networkConfig.chain,
    transport: http(networkConfig.rpcUrl),
  });

  console.log(`Deployer: ${account.address}`);

  // Get compiled contract
  const TheSeeds = await hre.artifacts.readArtifact("TheSeeds");

  // Deploy
  const deployHash = await client.deployContract({
    abi: TheSeeds.abi as any,
    bytecode: TheSeeds.bytecode as `0x${string}`,
    args: [account.address, account.address], // admin address, initial creator address
  });

  console.log(`Transaction hash: ${deployHash}`);
  console.log("Waiting for confirmation...");

  const deployReceipt = await publicClient.waitForTransactionReceipt({ hash: deployHash });
  const contractAddress = deployReceipt.contractAddress;

  if (!contractAddress) {
    throw new Error("Contract deployment failed - no address returned");
  }

  result.contractAddress = contractAddress;
  result.txHashes!.deployment = deployHash;

  console.log(`‚úÖ Contract deployed at: ${contractAddress}`);
  console.log(`   Block: ${deployReceipt.blockNumber}`);
  console.log(`   Explorer: ${networkConfig.explorer}/address/${contractAddress}`);

  // Wait for contract to be ready for reads
  const tempAbi = parseAbi(["function paused() view returns (bool)"]);
  await waitForContract(publicClient, contractAddress as Address, tempAbi);

  // Read CREATOR_ROLE hash from contract
  console.log("\nüìù Reading role hashes from contract...");
  const roleAbi = parseAbi(["function CREATOR_ROLE() view returns (bytes32)"]);
  CREATOR_ROLE = await publicClient.readContract({
    address: contractAddress as Address,
    abi: roleAbi,
    functionName: "CREATOR_ROLE",
  }) as Hex;
  console.log(`   CREATOR_ROLE: ${CREATOR_ROLE}`);

  // ============================================================
  // STEP 5: Update .env File
  // ============================================================
  updateEnvFile(contractAddress);

  // ============================================================
  // STEP 6: Update ABI Files
  // ============================================================
  updateAbiTypescriptFile(contractAddress);

  // ============================================================
  // STEP 7: Update Merkle Root on Contract
  // ============================================================
  console.log("\nüìù Updating Merkle root on contract...");

  // Use the full compiled ABI instead of parseAbi to include all errors
  const theSeedsAbi = TheSeeds.abi;

  const merkleUpdateHash = await client.writeContract({
    address: contractAddress as Address,
    abi: theSeedsAbi,
    functionName: "updateOwnershipRoot",
    args: [result.merkleRoot as Hex],
  });

  console.log(`Transaction hash: ${merkleUpdateHash}`);
  await publicClient.waitForTransactionReceipt({ hash: merkleUpdateHash });

  result.txHashes!.merkleUpdate = merkleUpdateHash;
  console.log(`‚úÖ Merkle root updated on contract`);

  // Verify
  const currentRoot = await publicClient.readContract({
    address: contractAddress as Address,
    abi: theSeedsAbi,
    functionName: "currentOwnershipRoot",
    args: [],
  });

  console.log(`   Verified root: ${currentRoot}`);

  // ============================================================
  // STEP 8: Grant CREATOR_ROLE to Relayer
  // ============================================================
  console.log("\nüìù Granting CREATOR_ROLE to relayer...");

  const relayerKey = (process.env.RELAYER_PRIVATE_KEY || process.env.PRIVATE_KEY) as string;
  const relayerAccount = privateKeyToAccount(
    (relayerKey.startsWith("0x") ? relayerKey : `0x${relayerKey}`) as Hex
  );

  console.log(`Relayer address: ${relayerAccount.address}`);

  // Check if already has role
  const hasRole = await publicClient.readContract({
    address: contractAddress as Address,
    abi: theSeedsAbi,
    functionName: "hasRole",
    args: [CREATOR_ROLE, relayerAccount.address],
  });

  if (hasRole) {
    console.log("‚úÖ Relayer already has CREATOR_ROLE");
  } else {
    const grantHash = await client.writeContract({
      address: contractAddress as Address,
      abi: theSeedsAbi,
      functionName: "addCreator",
      args: [relayerAccount.address],
    });

    console.log(`Transaction hash: ${grantHash}`);
    await publicClient.waitForTransactionReceipt({ hash: grantHash });

    result.txHashes!.creatorGrant = grantHash;
    console.log(`‚úÖ CREATOR_ROLE granted to relayer`);

    // Wait a moment for state to propagate
    console.log("   Waiting for state to propagate...");
    await sleep(2000);

    // Verify the role was actually granted
    const verifyRole = await publicClient.readContract({
      address: contractAddress as Address,
      abi: theSeedsAbi,
      functionName: "hasRole",
      args: [CREATOR_ROLE, relayerAccount.address],
    });

    if (!verifyRole) {
      console.error(`   ‚ùå Verification failed!`);
      console.error(`   CREATOR_ROLE used: ${CREATOR_ROLE}`);
      console.error(`   Relayer address: ${relayerAccount.address}`);
      throw new Error("Failed to grant CREATOR_ROLE - verification failed");
    }
    console.log("   Verified: Role successfully granted");
  }

  // ============================================================
  // STEP 9: Create Test Seed
  // ============================================================
  console.log("\nüìù Creating test seed...");
  console.log(`IPFS Hash: ${TEST_IPFS_HASH}`);

  const relayerClient = createWalletClient({
    account: relayerAccount,
    chain: networkConfig.chain,
    transport: http(networkConfig.rpcUrl),
  });

  let seedHash: Hex;
  let createdSeedId: bigint;

  try {
    // Simulate first to get the seed ID that will be created
    const { result: simulateResult } = await publicClient.simulateContract({
      address: contractAddress as Address,
      abi: theSeedsAbi,
      functionName: "submitSeed",
      args: [TEST_IPFS_HASH],
      account: relayerAccount,
    });

    // The submitSeed function returns the seed ID
    createdSeedId = simulateResult as bigint;
    console.log(`   Simulated seed ID: ${createdSeedId}`);

    seedHash = await relayerClient.writeContract({
      address: contractAddress as Address,
      abi: theSeedsAbi,
      functionName: "submitSeed",
      args: [TEST_IPFS_HASH],
    });

    console.log(`Transaction hash: ${seedHash}`);
    await publicClient.waitForTransactionReceipt({ hash: seedHash });

    result.txHashes!.testSeed = seedHash;
    result.testSeedId = Number(createdSeedId);

    console.log(`‚úÖ Test seed created with ID: ${result.testSeedId}`);
  } catch (error: any) {
    console.error("\n‚ùå Failed to create test seed");
    console.error("Error details:", error.message);
    if (error.message.includes("0xe2517d3f")) {
      console.error("\nThis error is likely an AccessControl issue.");
      console.error("Possible causes:");
      console.error("1. Relayer doesn't have CREATOR_ROLE (should have been granted above)");
      console.error("2. Contract is paused");
      console.error("3. ABI mismatch");
    }
    throw error;
  }

  // Fetch and display seed
  let id: bigint, creator: Address, ipfsHash: string, createdAt: bigint;

  try {
    console.log(`   Fetching seed #${result.testSeedId}...`);

    // Wait a moment for state to propagate before reading
    await sleep(2000);

    const seed = await publicClient.readContract({
      address: contractAddress as Address,
      abi: theSeedsAbi,
      functionName: "getSeed",
      args: [createdSeedId],
    });

    console.log("   Seed data received, parsing...");

    // Handle both object and array return formats from viem
    // viem may return structs as arrays or objects depending on version/config
    const s = seed as any;

    if (Array.isArray(seed) && seed.length >= 8) {
      // Array format: [id, creator, ipfsHash, votes, blessings, createdAt, minted, mintedInRound]
      id = seed[0] as bigint;
      creator = seed[1] as Address;
      ipfsHash = seed[2] as string;
      createdAt = seed[5] as bigint;
    } else {
      // Object format with named properties
      id = s.id;
      creator = s.creator;
      ipfsHash = s.ipfsHash;
      createdAt = s.createdAt;
    }
  } catch (error: any) {
    console.error("\n‚ùå Failed to fetch seed details");
    console.error("Error:", error.message);
    console.error("\nNote: Seed was created successfully but we couldn't fetch its details for display.");
    console.error("You can verify it was created by checking the transaction on the block explorer.");
    throw error;
  }

  // ============================================================
  // DEPLOYMENT COMPLETE - Summary
  // ============================================================
  console.log("\n");
  console.log("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
  console.log("‚ïë              üéâ DEPLOYMENT SUCCESSFUL üéâ                   ‚ïë");
  console.log("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
  console.log("\nüìã Deployment Summary:\n");
  console.log(`Network:          ${networkConfig.name}`);
  console.log(`Chain ID:         ${networkConfig.chain.id}`);
  console.log(`Contract Address: ${contractAddress}`);
  console.log(`Merkle Root:      ${result.merkleRoot}`);
  console.log(`Deployer:         ${account.address}`);
  console.log(`Relayer:          ${relayerAccount.address}`);

  console.log("\nüìù Test Seed Details:\n");
  console.log(`Seed ID:          ${id}`);
  console.log(`Creator:          ${creator}`);
  console.log(`IPFS Hash:        ${ipfsHash}`);
  console.log(`Created At:       ${new Date(Number(createdAt) * 1000).toISOString()}`);

  console.log("\nüîó Transaction Links:\n");
  console.log(`Deployment:       ${networkConfig.explorer}/tx/${result.txHashes!.deployment}`);
  console.log(`Merkle Update:    ${networkConfig.explorer}/tx/${result.txHashes!.merkleUpdate}`);
  if (result.txHashes!.creatorGrant) {
    console.log(`Creator Grant:    ${networkConfig.explorer}/tx/${result.txHashes!.creatorGrant}`);
  }
  console.log(`Test Seed:        ${networkConfig.explorer}/tx/${result.txHashes!.testSeed}`);

  console.log("\nüìÅ Updated Files:\n");
  console.log(`‚úÖ .env.local (added L2_SEEDS_CONTRACT)`);
  console.log(`‚úÖ lib/abi/TheSeeds.json (compiled ABI)`);
  console.log(`‚úÖ lib/abi/theSeeds.ts (TypeScript ABI with address)`);

  console.log("\nüöÄ Next Steps:\n");
  console.log(`1. Start the API:`);
  console.log(`   npm run dev`);
  console.log(``);
  console.log(`2. Test the seed endpoint:`);
  console.log(`   curl http://localhost:3000/api/seeds/0`);
  console.log(``);
  console.log(`3. Test blessing (requires Privy auth):`);
  console.log(`   POST /api/blessings`);
  console.log(`   { "seedId": 0 }`);
  console.log(``);
  console.log(`4. Set up daily snapshot updates:`);
  console.log(`   - Use cron: 0 0 * * * npm run update-snapshot`);
  console.log(`   - Or GitHub Actions (see README)`);
  console.log(``);
  console.log(`5. Grant RELAYER_ROLE for gasless blessings (optional):`);
  console.log(`   cast send ${contractAddress} "addRelayer(address)" ${relayerAccount.address} \\`);
  console.log(`     --rpc-url ${networkConfig.rpcUrl} --private-key $PRIVATE_KEY`);

  console.log("\n‚ú® Deployment configuration saved to deployment-result.json\n");

  // Save deployment result
  writeFileSync(
    "deployment-result.json",
    JSON.stringify(
      {
        network: networkName,
        networkName: networkConfig.name,
        chainId: networkConfig.chain.id,
        contractAddress,
        merkleRoot: result.merkleRoot,
        deployer: account.address,
        relayer: relayerAccount.address,
        testSeedId: result.testSeedId,
        txHashes: result.txHashes,
        timestamp: new Date().toISOString(),
        explorer: networkConfig.explorer,
      },
      null,
      2
    )
  );
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n‚ùå Deployment failed:", error.message || error);
    process.exit(1);
  });
